#include <Triangulation.h>
#include <ttkTriangulationWriter.h>

#include <array>

#include <vtkDataArray.h>
#include <vtkExecutive.h>
#include <vtkImageData.h>
#include <vtkInformation.h>
#include <vtkObjectFactory.h>
#include <vtkPointData.h>
#include <vtkUnstructuredGrid.h>

vtkStandardNewMacro(ttkTriangulationWriter);

ttkTriangulationWriter::ttkTriangulationWriter() {
  this->SetNumberOfInputPorts(1);
  this->setDebugMsgPrefix("TriangulationWriter");
}

int ttkTriangulationWriter::FillInputPortInformation(int port,
                                                     vtkInformation *info) {
  if(port == 0) {
    info->Set(vtkAlgorithm::INPUT_REQUIRED_DATA_TYPE(), "vtkDataSet");
    return 1;
  }
  return 0;
}

int ttkTriangulationWriter::OpenFile() {

  std::ofstream f(Filename, ios::out | ios::binary);

  if(!f.fail()) {
    Stream = std::move(f);
  } else {
    return -1;
  }

  return 0;
}

template <typename T>
void writeBin(std::ofstream &stream, const T var) {
  stream.write(reinterpret_cast<const char *>(&var), sizeof(var));
}

vtkDataArray *getValidArray(vtkPointData *const pd) {
  if(pd == nullptr) {
    return {};
  }

  // get first data array of input point data that is not generated by
  // Resample to Image
  vtkDataArray *arr{};

  // avoid "vtkGhostType" arrays generated by Resample to Image
  std::string ghost{vtkDataSetAttributes::GhostArrayName()};
  std::string ptmask{"vtkValidPointMask"};

  for(int i = 0; i < pd->GetNumberOfArrays(); ++i) {
    arr = pd->GetArray(i);
    if(arr != nullptr && arr->GetName() != ghost && arr->GetName() != ptmask) {
      break;
    }
  }
  if(arr == nullptr || arr->GetName() == ghost || arr->GetName() == ptmask) {
    return {};
  }

  return arr;
}

int ttkTriangulationWriter::writeImageData(vtkDataObject *input) {

  const auto dataSet = vtkImageData::SafeDownCast(input);

  if(dataSet == nullptr) {
    this->printErr("Requesting a vtkImageData");
    return 0;
  }

  if(this->OpenFile() == -1) {
    this->printErr("Could not open file `" + std::string{Filename} + "' :(");
    return 0;
  }

  // Dipha magic number
  writeBin<int64_t>(Stream, 8067171840);

  // Dipha type identifier (1 -> image data)
  writeBin<int64_t>(Stream, 1);

  // total number of values
  writeBin<int64_t>(Stream, dataSet->GetNumberOfPoints());

  // dimension
  std::array<int, 3> dims{};
  dataSet->GetDimensions(dims.data());
  int dim = dims[2] == 1 ? 2 : 3;
  writeBin<int64_t>(Stream, dim);

  // resolution
  writeBin<int64_t>(Stream, dims[0]);
  writeBin<int64_t>(Stream, dims[1]);
  if(dim == 3) {
    writeBin<int64_t>(Stream, dims[2]);
  }

  // actual data (first data array)
  const auto arr = getValidArray(dataSet->GetPointData());
  if(arr == nullptr) {
    return 0;
  }
  for(int i = 0; i < arr->GetNumberOfTuples(); ++i) {
    writeBin<double>(Stream, arr->GetTuple1(i));
  }

  return 1;
}

int ttkTriangulationWriter::writeUnstructuredGrid(vtkDataObject *input) {
  const auto dataSet = vtkUnstructuredGrid::SafeDownCast(input);

  if(dataSet == nullptr) {
    this->printErr("Requesting a vtkImageData");
    return 0;
  }

  if(this->OpenFile() == -1) {
    this->printErr("Could not open file `" + std::string{Filename} + "' :(");
    return 0;
  }

  auto triangulation = ttkAlgorithm::GetTriangulation(dataSet);
  if(triangulation == nullptr) {
    this->printErr("Missing triangulation");
    return 0;
  }
  const auto dim = triangulation->getDimensionality();
  // precondition triangulation
  triangulation->preconditionEdges();
  triangulation->preconditionTriangles();
  triangulation->preconditionTriangleEdges();
  if(dim == 3) {
    triangulation->preconditionCellTriangles();
  }

  // Dipha magic number
  writeBin<int64_t>(Stream, 8067171840);

  // Dipha type identifier (0 -> weighted boundary matrix)
  writeBin<int64_t>(Stream, 0);

  // boundary type (O -> boundary)
  writeBin<int64_t>(Stream, 0);

  // global number of cells (vertices + edges + triangles + tetras)
  const auto nVerts = triangulation->getNumberOfVertices();
  const auto nEdges = triangulation->getNumberOfEdges();
  const auto nTri = triangulation->getNumberOfTriangles();
  const auto nTetra = triangulation->getNumberOfCells();
  const auto num_simplices = nVerts + nEdges + nTri + (dim == 3 ? nTetra : 0);
  writeBin<int64_t>(Stream, num_simplices);

  // max dimension
  writeBin<int64_t>(Stream, dim);

  // cell dimensions
  for(int i = 0; i < nVerts; ++i) {
    writeBin<int64_t>(Stream, 0);
  }
  for(int i = 0; i < nEdges; ++i) {
    writeBin<int64_t>(Stream, 1);
  }
  for(int i = 0; i < nTri; ++i) {
    writeBin<int64_t>(Stream, 2);
  }
  if(dim == 3) {
    for(int i = 0; i < nTetra; ++i) {
      writeBin<int64_t>(Stream, 3);
    }
  }

  // actual data (first data array)
  const auto arr = getValidArray(dataSet->GetPointData());
  if(arr == nullptr) {
    return 0;
  }

  // cell values (max vertex value)
  using ttk::SimplexId;
  for(int i = 0; i < nVerts; ++i) {
    writeBin<double>(Stream, arr->GetTuple1(i));
  }
  for(int i = 0; i < nEdges; ++i) {
    SimplexId v0{}, v1{};
    triangulation->getEdgeVertex(i, 0, v0);
    triangulation->getEdgeVertex(i, 1, v1);
    writeBin<double>(Stream, std::max(arr->GetTuple1(v0), arr->GetTuple1(v1)));
  }
  for(int i = 0; i < nTri; ++i) {
    SimplexId v0{}, v1{}, v2{};
    triangulation->getTriangleVertex(i, 0, v0);
    triangulation->getTriangleVertex(i, 1, v1);
    triangulation->getTriangleVertex(i, 2, v2);
    writeBin<double>(
      Stream, std::max(std::max(arr->GetTuple1(v0), arr->GetTuple1(v1)),
                       arr->GetTuple1(v2)));
  }
  if(dim == 3) {
    for(int i = 0; i < nTetra; ++i) {
      SimplexId v0{}, v1{}, v2{}, v3{};
      triangulation->getCellVertex(i, 0, v0);
      triangulation->getCellVertex(i, 1, v1);
      triangulation->getCellVertex(i, 2, v2);
      triangulation->getCellVertex(i, 3, v3);
      writeBin<double>(
        Stream, std::max(std::max(arr->GetTuple1(v0), arr->GetTuple1(v1)),
                         std::max(arr->GetTuple1(v2), arr->GetTuple1(v3))));
    }
  }

  // cell offsets
  for(int i = 0; i < nVerts; ++i) {
    writeBin<int64_t>(Stream, 0);
  }
  for(int i = 0; i < nEdges; ++i) {
    writeBin<int64_t>(Stream, 2 * i);
  }
  for(int i = 0; i < nTri; ++i) {
    writeBin<int64_t>(Stream, 2 * nEdges + 3 * i);
  }
  if(dim == 3) {
    for(int i = 0; i < nTetra; ++i) {
      writeBin<int64_t>(Stream, 2 * nEdges + 3 * nTri + 4 * i);
    }
  }

  // number of entries in the boundary matrix
  const auto num_entries = 2 * nEdges + 3 * nTri + (dim == 3 ? 4 * nTetra : 0);
  writeBin<int64_t>(Stream, num_entries);

  // flattened boundary matrix
  for(int i = 0; i < nEdges; ++i) {
    SimplexId v0{}, v1{};
    triangulation->getEdgeVertex(i, 0, v0);
    triangulation->getEdgeVertex(i, 1, v1);
    writeBin<int64_t>(Stream, v0);
    writeBin<int64_t>(Stream, v1);
  }
  for(int i = 0; i < nTri; ++i) {
    SimplexId e0{}, e1{}, e2{};
    triangulation->getTriangleEdge(i, 0, e0);
    triangulation->getTriangleEdge(i, 1, e1);
    triangulation->getTriangleEdge(i, 2, e2);
    writeBin<int64_t>(Stream, e0 + nVerts);
    writeBin<int64_t>(Stream, e1 + nVerts);
    writeBin<int64_t>(Stream, e2 + nVerts);
  }
  if(dim == 3) {
    for(int i = 0; i < nTetra; ++i) {
      SimplexId t0{}, t1{}, t2{}, t3{};
      triangulation->getCellTriangle(i, 0, t0);
      triangulation->getCellTriangle(i, 1, t1);
      triangulation->getCellTriangle(i, 2, t2);
      triangulation->getCellTriangle(i, 3, t3);
      writeBin<int64_t>(Stream, t0 + nVerts + nEdges);
      writeBin<int64_t>(Stream, t1 + nVerts + nEdges);
      writeBin<int64_t>(Stream, t2 + nVerts + nEdges);
      writeBin<int64_t>(Stream, t3 + nVerts + nEdges);
    }
  }
  return 1;
}

int ttkTriangulationWriter::Write() {

  const auto dataset = this->GetInput();
  if(dataset->IsA("vtkImageData")) {
    return writeImageData(dataset);
  } else if(dataset->IsA("vtkUnstructuredGrid")) {
    return writeUnstructuredGrid(dataset);
  }

  return 0;
}

vtkDataObject *ttkTriangulationWriter::GetInput() {
  // copied from ParaView's vtkWriter::GetInput()
  if(this->GetNumberOfInputConnections(0) < 1) {
    return nullptr;
  }
  return this->GetExecutive()->GetInputData(0, 0);
}

void ttkTriangulationWriter::SetInputData(vtkDataObject *input) {
  // copied from ParaView's vtkWriter::SetInputData()
  this->SetInputDataInternal(0, input);
}
